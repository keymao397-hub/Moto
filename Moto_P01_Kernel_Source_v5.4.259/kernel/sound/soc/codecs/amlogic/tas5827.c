// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2025 GGEC, Inc. All rights reserved.
 */

#include <linux/module.h>  
#include <linux/input.h>  
#include <linux/gpio.h>  
#include <linux/delay.h>  
#include <linux/input.h>
#include <linux/interrupt.h> 
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/jiffies.h>
#include <linux/timer.h>
#include <linux/mutex.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/notifier.h>
#include <linux/list.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>
#include <linux/of_gpio.h>
#include <linux/sysfs.h>
#include <linux/moduleparam.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <linux/regmap.h>
#include <linux/of.h>
#include <asm/div64.h>
#include <linux/delay.h>

#include "tas5827.h"

#define ACM_VOLUME_MAX       (0xFF)  //定义最大音量增益
#define DEFALT_CODEC_VOLUME_REG_VAL 48
static int codec_left_vol;

static struct i2c_client *tas5827_client;
static int tas5827_major_60;
static struct class* tas5827_class_60;
static struct device* tas5827_device_60;
static int tas5827_major_61;
static struct class* tas5827_class_61;
static struct device* tas5827_device_61;
static int tas5827_left_volume = 1;
static int tas5827_right_volume = 1;
static int tas5827_mute = -1;//1:mute 0:unmute
static unsigned long long eq_mode = 0;

void left_volume_control(int vol);
void right_volume_control(int vol);

static int tas5827_i2c_read_reg(uint8_t reg_addr)
{
    uint8_t data;
	int ret = 0;
    struct i2c_msg msgs[] = {
        [0] = {
            .addr = tas5827_client->addr,
            .flags = 0,
            .len = sizeof(reg_addr),
            .buf = &reg_addr,
        },
 
        [1] = {
            .addr = tas5827_client->addr,
            .flags = 1,
            .len = sizeof(data),
            .buf = &data,
        },
    };

	ret =  i2c_transfer(tas5827_client->adapter, msgs, 2);
	if(ret < 0){
        printk("[GGEC]i2c_transfer read reg error\r\n");
        return ret;
    }

    return data;
}

static int tas5827_i2c_write_reg(uint8_t reg_addr, uint8_t data, uint8_t len)
{
    uint8_t buff[64];
	int status = -1;
	int count = 0;
	struct i2c_msg msgs = {
		.addr = tas5827_client->addr,
		.flags = 0,			   //write
		.len = len + 1,        //addr+data
		.buf = buff,
	};
	
    buff[0] = reg_addr;
    memcpy(&buff[1], &data, len);

	while ((status < 0) && (count < 5))
	{
		status = i2c_transfer(tas5827_client->adapter, &msgs, 1);
		count++;
		if (status < 0) {
			printk("[GGEC]i2c_transfer write reg(0x%x) error, cnt=%d\r\n", reg_addr, count);
			msleep(10);
		}
	}
	if (status < 0)
		return status;

    return 0;
}

static int tas5827_i2c_write_reg_list_wrap_version(uint8_t reg_addr, uint8_t* data, uint8_t len)
{
	uint8_t i = 0;
	uint8_t value_test;
	int ret;
	for (i = 0; i < len; i++) {
		printk("reg_addr0x%02x, val: 0x%02x\n", reg_addr + i, data[i]);
		ret = tas5827_i2c_write_reg(reg_addr + i, data[i], 1);
	}

	//debug begin
	printk("check value begin\n");
	for (i = 0; i < len; i++) {
		value_test = tas5827_i2c_read_reg(reg_addr + i);
		printk("reg_addr0x%02x, val: 0x%02x\n", reg_addr + i, value_test);
	}
	printk("check value end\n");
	return ret;
}

static int tas5827_i2c_write_reg_list(uint8_t reg_addr, uint8_t* data, uint8_t len)
{
    uint8_t buff[64];
	int status = -1;
	int count = 0;
	struct i2c_msg msgs = {
		.addr = tas5827_client->addr,
		.flags = 0,			   //write
		.len = len + 1,        //addr+data
		.buf = buff,
	};
	if (len > 0) {
		return tas5827_i2c_write_reg_list_wrap_version(reg_addr, data, len);
	}
    buff[0] = reg_addr;
    memcpy(&buff[1], data, len);

	while ((status < 0) && (count < 5))
	{
		status = i2c_transfer(tas5827_client->adapter, &msgs, 1);
		count++;
		if (status < 0) {
			printk("[GGEC]i2c_transfer write reg(0x%x) error, cnt=%d\r\n", reg_addr, count);
			msleep(10);
		}
	}
	if (status < 0)
		return status;

    return 0;
}

static int tas5827_set_dai_sysclk(struct snd_soc_dai *codec_dai,
				  int clk_id, unsigned int freq, int dir)
{
	tas5827_log(info,"sysclk:%d",freq);
	return 0;
}

static int tas5827_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
{
	int value;
	value = tas5827_i2c_read_reg(0x31);
	tas5827_log(info,"fmt:%d, value is 0x%X",fmt, value);
	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
	case SND_SOC_DAIFMT_CBS_CFS:
		printk("%s %d\n", __func__, __LINE__);
		break;
	default:
		printk("%s %d\n", __func__, __LINE__);
		return -EINVAL;
	}

	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
	case SND_SOC_DAIFMT_I2S:
		printk("%s %d\n", __func__, __LINE__);
		break;
	case SND_SOC_DAIFMT_RIGHT_J:
	case SND_SOC_DAIFMT_LEFT_J:
		printk("%s %d\n", __func__, __LINE__);
		break;
	default:
		printk("%s %d\n", __func__, __LINE__);
		return -EINVAL;
	}

	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
	case SND_SOC_DAIFMT_NB_NF:
		printk("%s %d\n", __func__, __LINE__);
		tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
		tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
		tas5827_i2c_write_reg(0x31, 0x0, 1);
		break;
	case SND_SOC_DAIFMT_NB_IF:
		printk("%s %d\n", __func__, __LINE__);
		tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
		tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
		tas5827_i2c_write_reg(0x31, 0x0, 1);
		break;
	case SND_SOC_DAIFMT_IB_NF:
		printk("%s %d\n", __func__, __LINE__);
		tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
		tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
		tas5827_i2c_write_reg(0x31, 0x20, 1);
		break;
	case SND_SOC_DAIFMT_IB_IF:
		printk("%s %d\n", __func__, __LINE__);
		tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
		tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
		tas5827_i2c_write_reg(0x31, 0x20, 1);
		break;
	default:
		printk("%s %d\n", __func__, __LINE__);
		return -EINVAL;
	}
	tas5827_log(info,"after fmt:%d, value is 0x%X",fmt, value);
	return 0;
}

int boost_en_soc = -1;
int hwmute = -1; //GPIO0, after regs init take effect

void soft_mute(int mute) {
	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0

	if (mute)
		tas5827_i2c_write_reg(0x03, 0x0f, 1);   //softmute
	else
		tas5827_i2c_write_reg(0x03, 0x03, 1);   //unmute
}

static void mute_control(int mute, int force)
{
    if ((mute == tas5827_mute) && (!force))
	{
		return;
	}

	tas5827_mute = mute;
#if 1
	//mute
	if (mute == 1)
	{
		if (force) {
			printk(KERN_EMERG "tas5827 force mute\n");
			gpio_direction_output(hwmute, 1); // so far no effect, just for hw debug
			left_volume_control(50);
			mdelay(2);
			left_volume_control(52);
			mdelay(2);
			left_volume_control(54);
			mdelay(2);
			left_volume_control(56);
			mdelay(2);
			left_volume_control(58);
			mdelay(2);
			left_volume_control(60);
			mdelay(2);
			left_volume_control(62);
			mdelay(2);
			left_volume_control(64);
			mdelay(2);
			left_volume_control(70);
			mdelay(2);
			left_volume_control(80);
			mdelay(2);
			left_volume_control(250);
			//soft_mute(1);
		} else {
			//printk(KERN_EMERG "tas5827 mute\n");
			gpio_direction_output(hwmute, 1); // so far no effect, just for hw debug
			//soft_mute(1); // because we enabled auto mute , so it is unnecessary to call here
		}
	}
	//unmute
	if (mute == 0)
	{
		left_volume_control(48);
		soft_mute(0);
		gpio_direction_output(hwmute, 0);
		//printk(KERN_EMERG "tas5827 unmute\n");
	}
#endif
}

static int tas5827_trigger(struct snd_pcm_substream * substream,int cmd,struct snd_soc_dai * dai)
{
	//printk(KERN_EMERG "tas5827_trigger , cmd is %d\n", cmd);
	switch(cmd) {
		case SNDRV_PCM_TRIGGER_START:
		case SNDRV_PCM_TRIGGER_RESUME:
		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
		mute_control(0, 0);
		break;
		case SNDRV_PCM_TRIGGER_STOP:
		case SNDRV_PCM_TRIGGER_SUSPEND:
		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
		mute_control(1, 0);
		break;
	}

	return 0;
}

static int tas5827_hw_params(struct snd_pcm_substream *substream,
			struct snd_pcm_hw_params *params,
			struct snd_soc_dai *dai)
{
	int chn_size;
	int format;
	int srate;
	int bclk;
	int value = 0;
	value = tas5827_i2c_read_reg(0x33);
	format = params_format(params);
	tas5827_log(info,"format:%X, value is 0x%X", format, value);

	switch (format)
	{
		case SNDRV_PCM_FORMAT_S16_LE:
			printk("%s %d\n", __func__, __LINE__);
			value = value & 0xfc;
			tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
			tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
			tas5827_i2c_write_reg(0x33, (uint8_t)value, 1);
			break;
		case SNDRV_PCM_FORMAT_S20_3LE:
			printk("%s %d\n", __func__, __LINE__);
			value = (value & 0xfc) + 1;
			tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
			tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
			tas5827_i2c_write_reg(0x33, (uint8_t)value, 1);
			break;
		case SNDRV_PCM_FORMAT_S24_LE:
			printk("%s %d\n", __func__, __LINE__);
			value = (value & 0xfc) + 2;
			tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
			tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
			tas5827_i2c_write_reg(0x33, (uint8_t)value, 1);
			break;
		case SNDRV_PCM_FORMAT_S32_LE:
			printk("%s %d\n", __func__, __LINE__);
			value = (value & 0xfc) + 3;
			tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
			tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
			tas5827_i2c_write_reg(0x33, (uint8_t)value, 1);
			break;
		default:
			break;	
	}

	srate = params_rate(params);
	chn_size = snd_pcm_format_physical_width(format);
	bclk = srate * 32 * 2; // params_channels(params);
	tas5827_log(info,"srate:%d, chn:2, chn_size:%d, bclk:%d", srate, chn_size, bclk);
	tas5827_log(info,"format:%X, value is 0x%X", format, value);
	return 0;
}

static int tas5827_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
{
	// printk(KERN_EMERG "[GGEC]tas5827_mute_stream() mute is %d\n", mute);
	if (mute)
		mute_control(1, 0);
	else
		mute_control(0, 0);
	return 0;
}

static const struct snd_soc_dai_ops tas5827_dai_ops = {
	.hw_params = tas5827_hw_params,
	.set_sysclk = tas5827_set_dai_sysclk,
	.set_fmt = tas5827_set_dai_fmt,
	.trigger = tas5827_trigger,
	.mute_stream  = tas5827_mute_stream,
};

static struct snd_soc_dai_driver tas5827_dai = {
	.name = "tas5827-aif",
	.playback = {
		.stream_name = "TAS5827 Playback",
		.channels_min = 1,
		.channels_max = 8,
		.rates = TAS5827_RATES,
		.formats = TAS5827_FORMATS,
	},
	.capture = {
		.stream_name = "TAS5827 Capture",
		.channels_min = 1,
		.channels_max = 8,
		.rates = TAS5827_RATES,
		.formats = TAS5827_FORMATS,
	},
	.ops = &tas5827_dai_ops,
};

int tas5827_GGECol_get(struct snd_kcontrol *kcontrol,
			struct snd_ctl_elem_value *ucontrol)
{
	int ret = 0;
	if (codec_left_vol == 0) {
		ret |= tas5827_i2c_read_reg(0x4c);  
		codec_left_vol = ret;
	}
	//printk("[GGEC]0x0f reg value is 0x%X\n", ret);
	ucontrol->value.integer.value[0] = codec_left_vol;

	return ret;
}

int tas5827_GGECol_put(struct snd_kcontrol *kcontrol,
			struct snd_ctl_elem_value *ucontrol)
{
	int ret = 0;
	int val;

	val = ucontrol->value.integer.value[0];
	printk(KERN_EMERG "[GGEC]left volume: %04x,%d\n", val,val);
	if((val > 0xFF) || (val < 0)){
		printk(KERN_EMERG "[GGEC]%d out of range",val);
	}
	codec_left_vol = val;
	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
	ret |= tas5827_i2c_write_reg(0x4c,val,1);
	return ret;
}

static const struct snd_kcontrol_new fsm_snd_controls[] =
{
	SOC_SINGLE_EXT("PAN_Left_Vol", SND_SOC_NOPM, 0, ACM_VOLUME_MAX, 0,
			tas5827_GGECol_get, tas5827_GGECol_put),
};

static void tas5827_add_codec_controls(struct snd_soc_codec *codec)
{
	snd_soc_add_codec_controls(codec, fsm_snd_controls,
				ARRAY_SIZE(fsm_snd_controls));
}

static int tas5827_codec_probe(struct snd_soc_codec *codec)
{
	tas5827_log(info,"entry");
	tas5827_add_codec_controls(codec);
	return 0;
}

static void tas5827_codec_remove(struct snd_soc_codec *codec)
{
#ifdef CONFIG_HAS_EARLYSUSPEND
	unregister_early_suspend(&early_suspend);
#endif
}

#ifdef CONFIG_PM
static int tas5827_codec_suspend(struct snd_soc_codec *codec)
{	
	dev_info(codec->dev, "tas5827_codec_suspend!\n");	
	
	return 0;
}

static int tas5827_codec_resume(struct snd_soc_codec *codec)
{
	dev_info(codec->dev, "tas5827_codec_resume!\n");	

	return 0;
}
#else
#define tas5827_codec_suspend NULL
#define tas5827_codec_resume NULL
#endif

#ifdef CONFIG_HAS_EARLYSUSPEND
static void tas5827_early_suspend(struct early_suspend *h)
{
	return;
}

static void tas5827_late_resume(struct early_suspend *h)
{
	return;
}
#endif

static const struct snd_soc_codec_driver tas5827_codec = {
	.probe = tas5827_codec_probe,
	.remove = tas5827_codec_remove,
	.suspend = tas5827_codec_suspend,
	.resume = tas5827_codec_resume,
};

//DEFINE_SPINLOCK(pwm_lock);
#define PWM_LOCK(...)  spin_lock(&pwm_lock);
#define PWM_UNLOCK(...) spin_unlock(&pwm_lock);

int pwm_gpio = 0;
int ratio = 10;
int g_value = 0;

static void pwm_function(struct timer_list *timer)
{
	g_value = !g_value;
	gpio_direction_output(pwm_gpio, g_value);
	if (g_value == 0) {
		mod_timer(timer, jiffies + (HZ  * ratio ) / 1000);
	} else {
		mod_timer(timer, jiffies + HZ / 1000);
	}
}

DEFINE_TIMER(pwm_timer, pwm_function);
static int tas5827_power_up(struct device_node *np)
{
	int tas5827_reset_pin1 = -1; // PDN
	
	int V1_8_en = -1; //DVDD
	int ret = -1;

	//DVDD on
	{
		V1_8_en = of_get_named_gpio(np, "V1_8_en", 0);
		if(V1_8_en < 0)
		{
			printk(KERN_EMERG "[GGEC]can't find V1_8_en gpio for tas5827\n");
			return V1_8_en;
		}

		printk(KERN_EMERG "[GGEC]V1_8_en number is  = %d\n",V1_8_en);
		ret = gpio_request(V1_8_en, "V1_8_en");
		if (ret < 0) {
			return ret;
		}

		gpio_direction_output(V1_8_en, 0);
		usleep_range(900, 1000);
		printk(KERN_EMERG "[GGEC][before]gpio value = %d\n",gpio_get_value(V1_8_en));
		gpio_direction_output(V1_8_en, 1);
		printk(KERN_EMERG "[GGEC][after]gpio value = %d\n",gpio_get_value(V1_8_en));
		mdelay(5);
	}
	// PDN
	{
		printk("[GGEC]addr is %X\n", tas5827_client->addr);
		tas5827_reset_pin1 = of_get_named_gpio(np, "tas5827_reset_pin1", 0);
		if(tas5827_reset_pin1 < 0)
		{
			printk(KERN_EMERG "[GGEC]can't find tas5827_reset_pin1 gpio for tas5827\n");
			return tas5827_reset_pin1;
		}
		
		printk(KERN_EMERG "[GGEC]tas5827_reset_pin1 number is  = %d\n",tas5827_reset_pin1);
		ret = gpio_request(tas5827_reset_pin1, "tas5827_reset_pin1");
		if (ret < 0) {
			return ret;
		}

		gpio_direction_output(tas5827_reset_pin1, 0);
		usleep_range(900, 1000);
		printk(KERN_EMERG "[GGEC][before]gpio value = %d\n",gpio_get_value(tas5827_reset_pin1));
		gpio_direction_output(tas5827_reset_pin1, 1);
		printk(KERN_EMERG "[GGEC][after]gpio value = %d\n",gpio_get_value(tas5827_reset_pin1));
		mdelay(5);
	}
	// boost en
	{
		boost_en_soc = of_get_named_gpio(np, "boost_en_soc", 0);
		if(boost_en_soc < 0)
		{
			printk(KERN_EMERG "[GGEC]can't find boost_en_soc gpio for tas5827\n");
			return boost_en_soc;
		}
	
		printk(KERN_EMERG "[GGEC]boost_en_soc number is  = %d\n",boost_en_soc);
		ret = gpio_request(boost_en_soc, "boost_en_soc");
		if (ret < 0) {
			return ret;
		}
	
		gpio_direction_output(boost_en_soc, 0);
		usleep_range(900, 1000);
		printk(KERN_EMERG "[GGEC][before]gpio value = %d\n",gpio_get_value(boost_en_soc));
		gpio_direction_output(boost_en_soc, 1);
		printk(KERN_EMERG "[GGEC][after]gpio value = %d\n",gpio_get_value(boost_en_soc));
		mdelay(5);
	}
	//AMP_MUTE
	{
		hwmute = of_get_named_gpio(np, "hwmute", 0);
		if(hwmute < 0)
		{
			printk(KERN_EMERG "[GGEC]can't find hwmute gpio for tas5827\n");
			return 0;
		}

		printk(KERN_EMERG "[GGEC]hwmute number is  = %d\n",hwmute);
		ret = gpio_request(hwmute, "hwmute");
		if (ret < 0) {
			return ret;
		}

		gpio_direction_output(hwmute, 1);
		g_value = 0;
		printk(KERN_EMERG "[GGEC][before]gpio value = %d\n",gpio_get_value(hwmute));
		mdelay(5);
		pwm_gpio = hwmute;
		pwm_timer.expires = jiffies + HZ/10;
#ifdef ENABLE_PWM_TIMER_SW
		add_timer(&pwm_timer);
#endif
	}
	return ret;
}

#ifdef FIRST_DBG
static int tas5827_fast_init(struct i2c_client *i2c_client)
{
	int ret = -1;

	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0

	ret = tas5827_i2c_write_reg(0x3, 0x02, 1);
	if(ret < 0)
	{
		printk(KERN_EMERG "[lw-debug]tas5827_i2c_write_reg 0x03 val=0x2 failed!\n");
		return ret;
	}

    ret = tas5827_i2c_write_reg(0x3, 0x03, 1);
	if(ret < 0)
	{
		printk(KERN_EMERG "[lw-debug]tas5827_i2c_write_reg 0x03 val=0x3 failed!\n");
		return ret;
	}
	return 0;
}
#else

void transmit_registers(cfg_reg *r, int n)
{
	int i = 0;
	int ret = 0;

	while (i < n) {
		switch (r[i].command) {
			case CFG_META_SWITCH:
			// Used in legacy applications.  Ignored here.
			break;
			case CFG_META_DELAY:
				//udelay(r[i].param * 1000);
				break;
			case CFG_META_BURST:
				tas5827_i2c_write_reg_list(r[i+1].command, &r[i+1].param, r[i].param);
				i +=  (r[i].param / 2) + 1;
			break;
		default:
			ret = tas5827_i2c_write_reg(r[i].command, r[i].param, 1);
			if (ret < 0) {
				printk(KERN_EMERG "transmit_registers fail\n");
				return;
			}
			break;
		}
		i++;
	}
}

static int tas5827_reg_init(struct i2c_client *i2c_client)
{
	transmit_registers(registers, sizeof(registers) / sizeof(registers[0]));
	return 0;
}

#ifdef EQ_12BAND_MODE
// freq : 100HZ
unsigned char band1_reg[9][21] = {
	{0x30,0x07,0xfb,0x2a,0xf6,0xf0,0x2f,0x56,0x12,0x07,0xd5,0xd7,0xc6,0x0f,0xd0,0xa9,0xee,0xf8,0x2e,0xfd,0x44},
	{0x30,0x07,0xfc,0x7a,0xd6,0xf0,0x2c,0xbc,0x84,0x07,0xd7,0x21,0x83,0x0f,0xd3,0x43,0x7c,0xf8,0x2c,0x63,0xa7},
	{0x30,0x07,0xfd,0xb8,0x51,0xf0,0x2a,0x47,0x67,0x07,0xd8,0x59,0x32,0x0f,0xd5,0xb8,0x99,0xf8,0x29,0xee,0x7d},
	{0x30,0x07,0xfe,0xe4,0x65,0xf0,0x27,0xf4,0xc8,0x07,0xd9,0x7f,0xca,0x0f,0xd8,0x0b,0x38,0xf8,0x27,0x9b,0xd1},
	{0x30,0x08,0x00,0x00,0x00,0xf0,0x25,0xc2,0xcd,0x07,0xda,0x96,0x37,0x0f,0xda,0x3d,0x33,0xf8,0x25,0x69,0xc9},
	{0x30,0x08,0x01,0x1b,0xc2,0xf0,0x25,0xc2,0xcd,0x07,0xd9,0x7a,0x74,0x0f,0xda,0x3d,0x33,0xf8,0x25,0x69,0xc9},
	{0x30,0x08,0x02,0x48,0x55,0xf0,0x25,0xc2,0xcd,0x07,0xd8,0x4d,0xe2,0x0f,0xda,0x3d,0x33,0xf8,0x25,0x69,0xc9},
	{0x30,0x08,0x03,0x86,0xb7,0xf0,0x25,0xc2,0xcd,0x07,0xd7,0x0f,0x7f,0x0f,0xda,0x3d,0x33,0xf8,0x25,0x69,0xc9},
	{0x30,0x08,0x04,0xd7,0xf7,0xf0,0x25,0xc2,0xcd,0x07,0xd5,0xbe,0x40,0x0f,0xda,0x3d,0x33,0xf8,0x25,0x69,0xc9}
};

// freq : 170HZ
unsigned char band2_reg[9][21] = {
	{0x44,0x07,0xf7,0xd9,0xc9,0xf0,0x50,0x3d,0x6f,0x07,0xb8,0xe7,0x5f,0x0f,0xaf,0xc2,0x91,0xf8,0x4f,0x3e,0xd8},
	{0x44,0x07,0xfa,0x0f,0x8e,0xf0,0x4b,0xe3,0xa2,0x07,0xbb,0x0b,0xaf,0x0f,0xb4,0x1c,0x5e,0xf8,0x4a,0xe4,0xc4},
	{0x44,0x07,0xfc,0x26,0xcd,0xf0,0x47,0xc5,0xeb,0x07,0xbd,0x12,0x69,0x0f,0xb8,0x3a,0x15,0xf8,0x46,0xc6,0xca},
	{0x44,0x07,0xfe,0x21,0x1c,0xf0,0x43,0xe1,0x2a,0x07,0xbe,0xfd,0x19,0x0f,0xbc,0x1e,0xd6,0xf8,0x42,0xe1,0xca},
	{0x44,0x08,0x00,0x00,0x00,0xf0,0x40,0x32,0x66,0x07,0xc0,0xcd,0x36,0x0f,0xbf,0xcd,0x9a,0xf8,0x3f,0x32,0xca},
	{0x44,0x08,0x01,0xdf,0x54,0xf0,0x40,0x32,0x66,0x07,0xbe,0xed,0xe2,0x0f,0xbf,0xcd,0x9a,0xf8,0x3f,0x32,0xca},
	{0x44,0x08,0x03,0xdb,0x0e,0xf0,0x40,0x32,0x66,0x07,0xbc,0xf2,0x28,0x0f,0xbf,0xcd,0x9a,0xf8,0x3f,0x32,0xca},
	{0x44,0x08,0x05,0xf4,0xde,0xf0,0x40,0x32,0x66,0x07,0xba,0xd8,0x57,0x0f,0xbf,0xcd,0x9a,0xf8,0x3f,0x32,0xca},
	{0x44,0x08,0x08,0x2e,0x8d,0xf0,0x40,0x32,0x66,0x07,0xb8,0x9e,0xa9,0x0f,0xbf,0xcd,0x9a,0xf8,0x3f,0x32,0xca}
};

// freq : 260HZ
unsigned char band3_reg[9][21] = {
	{0x58,0x07,0xf3,0xa9,0xab,0xf0,0x7a,0x45,0xce,0x07,0x94,0x5d,0xf8,0x0f,0x85,0xba,0x32,0xf8,0x77,0xf8,0x5d},
	{0x58,0x07,0xf7,0x00,0xe8,0xf0,0x73,0xc0,0x56,0x07,0x97,0x8d,0x2c,0x0f,0x8c,0x3f,0xaa,0xf8,0x71,0x71,0xed},
	{0x58,0x07,0xfa,0x2a,0xe2,0xf0,0x6d,0x93,0x37,0x07,0x9a,0x91,0x3b,0x0f,0x92,0x6c,0xc9,0xf8,0x6b,0x43,0xe3},
	{0x58,0x07,0xfd,0x29,0xdc,0xf0,0x67,0xba,0x08,0x07,0x9d,0x6c,0x4e,0x0f,0x98,0x45,0xf8,0xf8,0x65,0x69,0xd7},
	{0x58,0x08,0x00,0x00,0x00,0xf0,0x62,0x30,0x90,0x07,0xa0,0x20,0x74,0x0f,0x9d,0xcf,0x70,0xf8,0x5f,0xdf,0x8c},
	{0x58,0x08,0x02,0xd7,0x26,0xf0,0x62,0x30,0x90,0x07,0x9d,0x49,0x4e,0x0f,0x9d,0xcf,0x70,0xf8,0x5f,0xdf,0x8c},
	{0x58,0x08,0x05,0xd9,0x62,0xf0,0x62,0x30,0x90,0x07,0x9a,0x47,0x11,0x0f,0x9d,0xcf,0x70,0xf8,0x5f,0xdf,0x8c},
	{0x58,0x08,0x09,0x09,0x42,0xf0,0x62,0x30,0x90,0x07,0x97,0x17,0x32,0x0f,0x9d,0xcf,0x70,0xf8,0x5f,0xdf,0x8c},
	{0x58,0x08,0x0c,0x69,0x79,0xf0,0x62,0x30,0x90,0x07,0x93,0xb6,0xfa,0x0f,0x9d,0xcf,0x70,0xf8,0x5f,0xdf,0x8c}
};

// freq : 300HZ
unsigned char band4_reg[9][21] = {
	{0x6c,0x07,0xf1,0xd4,0x1e,0xf0,0x8c,0xdb,0x97,0x07,0x84,0x5d,0x82,0x0f,0x73,0x24,0x69,0xf8,0x89,0xce,0x60},
	{0x6c,0x07,0xf5,0xa9,0xdc,0xf0,0x85,0x66,0x6c,0x07,0x87,0xfe,0x69,0x0f,0x7a,0x99,0x94,0xf8,0x82,0x57,0xbb},
	{0x6c,0x07,0xf9,0x4c,0x15,0xf0,0x7e,0x55,0x6e,0x07,0x8b,0x6e,0x92,0x0f,0x81,0xaa,0x92,0xf8,0x7b,0x45,0x58},
	{0x6c,0x07,0xfc,0xbd,0x53,0xf0,0x77,0xa3,0xb4,0x07,0x8e,0xb0,0x62,0x0f,0x88,0x5c,0x4c,0xf8,0x74,0x92,0x4c},
	{0x6c,0x08,0x00,0x00,0x00,0xf0,0x71,0x4c,0x87,0x07,0x91,0xc6,0x22,0x0f,0x8e,0xb3,0x79,0xf8,0x6e,0x39,0xde},
	{0x6c,0x08,0x03,0x44,0x02,0xf0,0x71,0x4c,0x87,0x07,0x8e,0x82,0x20,0x0f,0x8e,0xb3,0x79,0xf8,0x6e,0x39,0xde},
	{0x6c,0x08,0x06,0xb9,0x8d,0xf0,0x71,0x4c,0x87,0x07,0x8b,0x0c,0x95,0x0f,0x8e,0xb3,0x79,0xf8,0x6e,0x39,0xde},
	{0x6c,0x08,0x0a,0x63,0x91,0xf0,0x71,0x4c,0x87,0x07,0x87,0x62,0x91,0x0f,0x8e,0xb3,0x79,0xf8,0x6e,0x39,0xde},
	{0x6c,0x08,0x0e,0x45,0x29,0xf0,0x71,0x4c,0x87,0x07,0x83,0x80,0xf9,0x0f,0x8e,0xb3,0x79,0xf8,0x6e,0x39,0xde}
};

// freq : 630HZ
unsigned char band5_reg[9][21] = {
	{0x08,0x07,0xe3,0x4d,0x56,0xf1,0x24,0x09,0x6e,0x07,0x05,0xa1,0xfd,0x0e,0xdb,0xf6,0x92,0xf9,0x17,0x10,0xad},
	{0x08,0x07,0xeb,0x07,0x09,0xf1,0x15,0x7b,0xd6,0x07,0x0c,0x82,0x97,0x0e,0xea,0x84,0x2a,0xf9,0x08,0x76,0x60},
	{0x08,0x07,0xf2,0x60,0x0c,0xf1,0x07,0xa4,0x64,0x07,0x13,0x0d,0x1c,0x0e,0xf8,0x5b,0x9c,0xf8,0xfa,0x92,0xd8},
	{0x08,0x07,0xf9,0x5c,0x63,0xf0,0xfa,0x7b,0x82,0x07,0x19,0x45,0x23,0x0f,0x05,0x84,0x7e,0xf8,0xed,0x5e,0x7a},
	{0x08,0x08,0x00,0x00,0x00,0xf0,0xed,0xf9,0xc7,0x07,0x1f,0x2e,0x2c,0x0f,0x12,0x06,0x39,0xf8,0xe0,0xd1,0xd4},
	{0x08,0x08,0x06,0xa9,0x24,0xf0,0xed,0xf9,0xc7,0x07,0x18,0x85,0x09,0x0f,0x12,0x06,0x39,0xf8,0xe0,0xd1,0xd4},
	{0x08,0x08,0x00,0x00,0x00,0xf0,0xed,0xf9,0xc7,0x07,0x1f,0x2e,0x2c,0x0f,0x12,0x06,0x39,0xf8,0xe0,0xd1,0xd4},
	{0x08,0x08,0x15,0x30,0x83,0xf0,0xed,0xf9,0xc7,0x07,0x09,0xfd,0xa9,0x0f,0x12,0x06,0x39,0xf8,0xe0,0xd1,0xd4},
	{0x08,0x08,0x1d,0x1b,0x13,0xf0,0xed,0xf9,0xc7,0x07,0x02,0x13,0x19,0x0f,0x12,0x06,0x39,0xf8,0xe0,0xd1,0xd4}
};

// freq : 1000HZ
unsigned char band6_reg[9][21] = {
	{0x1c,0x07,0xd4,0x33,0x49,0xf1,0xc9,0x50,0xed,0x06,0x81,0xe1,0xb1,0x0e,0x36,0xaf,0x13,0xf9,0xa9,0xeb,0x06},
	{0x1c,0x07,0xdf,0xed,0x30,0xf1,0xb4,0x06,0xe3,0x06,0x8b,0xa0,0xdb,0x0e,0x4b,0xf9,0x1d,0xf9,0x94,0x71,0xf4},
	{0x1c,0x07,0xeb,0x1f,0x94,0xf1,0x9f,0xb2,0xdf,0x06,0x94,0xef,0x63,0x0e,0x60,0x4d,0x21,0xf9,0x7f,0xf1,0x08},
	{0x1c,0x07,0xf5,0xcf,0x00,0xf1,0x8c,0x4c,0xa2,0x06,0x9d,0xd1,0x0e,0x0e,0x73,0xb3,0x5e,0xf9,0x6c,0x5f,0xf1},
	{0x1c,0x08,0x00,0x00,0x00,0xf1,0x79,0xcb,0xec,0x06,0xa6,0x49,0xa5,0x0e,0x86,0x34,0x14,0xf9,0x59,0xb6,0x5b},
	{0x1c,0x08,0x0a,0x3e,0x0c,0xf1,0x79,0xcb,0xec,0x06,0x9c,0x0b,0x99,0x0e,0x86,0x34,0x14,0xf9,0x59,0xb6,0x5b},
	{0x1c,0x08,0x15,0x17,0x76,0xf1,0x79,0xcb,0xec,0x06,0x91,0x32,0x2f,0x0e,0x86,0x34,0x14,0xf9,0x59,0xb6,0x5b},
	{0x1c,0x08,0x20,0x95,0x72,0xf1,0x79,0xcb,0xec,0x06,0x85,0xb4,0x33,0x0e,0x86,0x34,0x14,0xf9,0x59,0xb6,0x5b},
	{0x1c,0x08,0x2c,0xc1,0xc1,0xf1,0x79,0xcb,0xec,0x06,0x79,0x87,0xe4,0x0e,0x86,0x34,0x14,0xf9,0x59,0xb6,0x5b}
};

// freq : 1800HZ
unsigned char band7_reg[9][21] = {
	{0x30,0x07,0xb7,0x37,0x22,0xf3,0x21,0x64,0x46,0x05,0x85,0x02,0x88,0x0c,0xde,0x9b,0xba,0xfa,0xc3,0xc6,0x56},
	{0x30,0x07,0xca,0x7e,0x8c,0xf3,0x01,0x3c,0x21,0x05,0x92,0xcd,0x2e,0x0c,0xfe,0xc3,0xdf,0xfa,0xa2,0xb4,0x47},
	{0x30,0x07,0xdd,0x0b,0x1c,0xf2,0xe2,0x4b,0xa6,0x05,0xa0,0x12,0x29,0x0d,0x1d,0xb4,0x5a,0xfa,0x82,0xe2,0xbc},
	{0x30,0x07,0xee,0xdf,0xd0,0xf2,0xc4,0x8d,0xd8,0x05,0xac,0xd3,0x9c,0x0d,0x3b,0x72,0x28,0xfa,0x64,0x4c,0x94},
	{0x30,0x08,0x00,0x00,0x00,0xf2,0xa7,0xfd,0x21,0x05,0xb9,0x13,0xed,0x0d,0x58,0x02,0xdf,0xfa,0x46,0xec,0x13},
	{0x30,0x08,0x11,0x45,0x29,0xf2,0xa7,0xfd,0x21,0x05,0xa7,0xce,0xc5,0x0d,0x58,0x02,0xdf,0xfa,0x46,0xec,0x13},
	{0x30,0x08,0x23,0x90,0x4a,0xf2,0xa7,0xfd,0x21,0x05,0x95,0x83,0xa3,0x0d,0x58,0x02,0xdf,0xfa,0x46,0xec,0x13},
	{0x30,0x08,0x36,0xf0,0xe9,0xf2,0xa7,0xfd,0x21,0x05,0x82,0x23,0x04,0x0d,0x58,0x02,0xdf,0xfa,0x46,0xec,0x13},
	{0x30,0x08,0x4b,0x77,0x78,0xf2,0xa7,0xfd,0x21,0x05,0x6d,0x9c,0x75,0x0d,0x58,0x02,0xdf,0xfa,0x46,0xec,0x13}
};

// freq : 2600HZ
unsigned char band8_reg[9][21] = {
	{0x30,0x07,0x9e,0x5d,0x67,0xf4,0x69,0xe8,0xd7,0x04,0xac,0x35,0x57,0x0b,0x96,0x17,0x29,0xfb,0xb5,0x6d,0x41},
	{0x30,0x07,0xb7,0xfc,0x75,0xf4,0x42,0xf1,0xea,0x04,0xbb,0xec,0x2c,0x0b,0xbd,0x0e,0x16,0xfb,0x8c,0x17,0x5f},
	{0x30,0x07,0xd0,0xcc,0xb9,0xf4,0x1d,0x35,0x77,0x04,0xcb,0x24,0x2e,0x0b,0xe2,0xca,0x89,0xfb,0x64,0x0f,0x18},
	{0x30,0x07,0xe8,0xcd,0xcf,0xf3,0xf8,0xb4,0x19,0x04,0xd9,0xdd,0x1e,0x0c,0x07,0x4b,0xe7,0xfb,0x3d,0x55,0x13},
	{0x30,0x08,0x00,0x00,0x00,0xf3,0xd5,0x6d,0x5f,0x04,0xe8,0x17,0x29,0x0c,0x2a,0x92,0xa1,0xfb,0x17,0xe8,0xd7},
	{0x30,0x08,0x17,0x76,0x38,0xf3,0xd5,0x6d,0x5f,0x04,0xd0,0xa0,0xf1,0x0c,0x2a,0x92,0xa1,0xfb,0x17,0xe8,0xd7},
	{0x30,0x08,0x30,0x50,0x54,0xf3,0xd5,0x6d,0x5f,0x04,0xb7,0xc6,0xd5,0x0c,0x2a,0x92,0xa1,0xfb,0x17,0xe8,0xd7},
	{0x30,0x08,0x4a,0xa3,0x6b,0xf3,0xd5,0x6d,0x5f,0x04,0x9d,0x73,0xbe,0x0c,0x2a,0x92,0xa1,0xfb,0x17,0xe8,0xd7},
	{0x30,0x08,0x66,0x85,0xd3,0xf3,0xd5,0x6d,0x5f,0x04,0x81,0x91,0x57,0x0c,0x2a,0x92,0xa1,0xfb,0x17,0xe8,0xd7}
};

// freq : 4000HZ
unsigned char band9_reg[9][21] = {
	{0x44,0x07,0x7a,0x75,0xa4,0xf6,0x89,0x5c,0xa4,0x03,0x72,0xf6,0x46,0x09,0x76,0xa3,0x5c,0xfd,0x12,0x94,0x16},
	{0x44,0x07,0x9d,0x06,0x61,0xf6,0x5d,0x9f,0x13,0x03,0x82,0xe7,0x5f,0x09,0xa2,0x60,0xed,0xfc,0xe0,0x12,0x40},
	{0x44,0x07,0xbe,0xd2,0x6c,0xf6,0x32,0xda,0x69,0x03,0x92,0x7d,0xc1,0x09,0xcd,0x25,0x97,0xfc,0xae,0xaf,0xd2},
	{0x44,0x07,0xdf,0xd2,0x6b,0xf6,0x09,0x17,0xf6,0x03,0xa1,0xb6,0x07,0x09,0xf6,0xe8,0x0a,0xfc,0x7e,0x77,0x8e},
	{0x44,0x08,0x00,0x00,0x00,0xf5,0xe0,0x5f,0xc7,0x03,0xb0,0x8d,0x42,0x0a,0x1f,0xa0,0x39,0xfc,0x4f,0x72,0xbe},
	{0x44,0x08,0x20,0xb1,0x14,0xf5,0xe0,0x5f,0xc7,0x03,0x8f,0xdc,0x2e,0x0a,0x1f,0xa0,0x39,0xfc,0x4f,0x72,0xbe},
	{0x44,0x08,0x43,0x52,0x0e,0xf5,0xe0,0x5f,0xc7,0x03,0x6d,0x3b,0x35,0x0a,0x1f,0xa0,0x39,0xfc,0x4f,0x72,0xbe},
	{0x44,0x08,0x68,0x00,0x50,0xf5,0xe0,0x5f,0xc7,0x03,0x48,0x8c,0xf2,0x0a,0x1f,0xa0,0x39,0xfc,0x4f,0x72,0xbe},
	{0x44,0x08,0x8e,0xda,0xfb,0xf5,0xe0,0x5f,0xc7,0x03,0x21,0xb2,0x47,0x0a,0x1f,0xa0,0x39,0xfc,0x4f,0x72,0xbe}
};

// freq : 6500HZ
unsigned char band10_reg[9][21] = {
	{0x58,0x07,0x4a,0xe2,0x64,0xf9,0xfc,0x91,0x05,0x01,0xd3,0xe7,0xa8,0x06,0x03,0x6e,0xfb,0xfe,0xe1,0x35,0xf4},
	{0x58,0x07,0x78,0xe5,0x1c,0xf9,0xd6,0xa0,0x48,0x01,0xdf,0x6f,0xce,0x06,0x29,0x5f,0xb8,0xfe,0xa7,0xab,0x15},
	{0x58,0x07,0xa6,0x76,0x6a,0xf9,0xb1,0x0d,0x12,0x01,0xea,0xdb,0x87,0x06,0x4e,0xf2,0xee,0xfe,0x6e,0xae,0x0f},
	{0x58,0x07,0xd3,0x84,0xe7,0xf9,0x8b,0xe5,0xba,0x01,0xf6,0x26,0x77,0x06,0x74,0x1a,0x46,0xfe,0x36,0x54,0xa2},
	{0x58,0x08,0x00,0x00,0x00,0xf9,0x67,0x37,0xec,0x02,0x01,0x4c,0x76,0x06,0x98,0xc8,0x14,0xfd,0xfe,0xb3,0x8a},
	{0x58,0x08,0x2d,0x77,0xe8,0xf9,0x67,0x37,0xec,0x01,0xd3,0xd4,0x8e,0x06,0x98,0xc8,0x14,0xfd,0xfe,0xb3,0x8a},
	{0x58,0x08,0x5d,0xa1,0x85,0xf9,0x67,0x37,0xec,0x01,0xa3,0xaa,0xf1,0x06,0x98,0xc8,0x14,0xfd,0xfe,0xb3,0x8a},
	{0x58,0x08,0x90,0xa5,0xb6,0xf9,0x67,0x37,0xec,0x01,0x70,0xa6,0xc0,0x06,0x98,0xc8,0x14,0xfd,0xfe,0xb3,0x8a},
	{0x58,0x08,0xc6,0xaf,0xc4,0xf9,0x67,0x37,0xec,0x01,0x3a,0x9c,0xb2,0x06,0x98,0xc8,0x14,0xfd,0xfe,0xb3,0x8a}
};

// freq : 10000HZ
unsigned char band11_reg[9][21] = {
	{0x6c,0x07,0x1d,0xbe,0xc3,0xfe,0x15,0x51,0xb1,0x00,0x4a,0x19,0xa8,0x01,0xea,0xae,0x4f,0x00,0x98,0x27,0x95},
	{0x6c,0x07,0x56,0x2e,0x0a,0xfe,0x06,0x1e,0x5e,0x00,0x4c,0x65,0x4f,0x01,0xf9,0xe1,0xa2,0x00,0x5d,0x6c,0xa7},
	{0x6c,0x07,0x8e,0xc3,0x4c,0xfd,0xf6,0xe0,0xd0,0x00,0x4e,0xb2,0x80,0x02,0x09,0x1f,0x30,0x00,0x22,0x8a,0x34},
	{0x6c,0x07,0xc7,0x66,0x9e,0xfd,0xe7,0x9f,0x78,0x00,0x51,0x00,0x44,0x02,0x18,0x60,0x88,0xff,0xe7,0x99,0x1e},
	{0x6c,0x08,0x00,0x00,0x00,0xfd,0xd8,0x60,0xcd,0x00,0x53,0x4d,0xa1,0x02,0x27,0x9f,0x33,0xff,0xac,0xb2,0x5f},
	{0x6c,0x08,0x3a,0x35,0x32,0xfd,0xd8,0x60,0xcd,0x00,0x19,0x18,0x6e,0x02,0x27,0x9f,0x33,0xff,0xac,0xb2,0x5f},
	{0x6c,0x08,0x77,0xdd,0x58,0xfd,0xd8,0x60,0xcd,0xff,0xdb,0x70,0x48,0x02,0x27,0x9f,0x33,0xff,0xac,0xb2,0x5f},
	{0x6c,0x08,0xb9,0x2c,0xc3,0xfd,0xd8,0x60,0xcd,0xff,0x9a,0x20,0xdd,0x02,0x27,0x9f,0x33,0xff,0xac,0xb2,0x5f},
	{0x6c,0x08,0xfe,0x5a,0xdf,0xfd,0xd8,0x60,0xcd,0xff,0x54,0xf2,0xc2,0x02,0x27,0x9f,0x33,0xff,0xac,0xb2,0x5f}
};

// band12 -- 17Khz
unsigned char band12_reg[9][21] = {
	{0x08,0x06,0xe8,0x78,0x7c,0x03,0x46,0xbf,0x14,0xfe,0x79,0x52,0x2c,0xfc,0xb9,0x40,0xec,0x02,0x9e,0x35,0x58},
	{0x08,0x07,0x2c,0xa6,0xe6,0x03,0x67,0x15,0x52,0xfe,0x6a,0x42,0x41,0xfc,0x98,0xea,0xae,0x02,0x69,0x16,0xd9},
	{0x08,0x07,0x72,0x06,0xa0,0x03,0x87,0xfc,0x5d,0xfe,0x5a,0xee,0xe4,0xfc,0x78,0x03,0xa3,0x02,0x33,0x0a,0x7c},
	{0x08,0x07,0xb8,0x81,0x93,0x03,0xa9,0x69,0xbc,0xfe,0x4b,0x5c,0xf6,0xfc,0x56,0x96,0x44,0x01,0xfc,0x21,0x77},
	{0x08,0x08,0x00,0x00,0x00,0x03,0xcb,0x52,0x2b,0xfe,0x3b,0x91,0xb5,0xfc,0x34,0xad,0xd5,0x01,0xc4,0x6e,0x4b},
	{0x08,0x08,0x4a,0x14,0x76,0x03,0xcb,0x52,0x2b,0xfd,0xf1,0x7d,0x40,0xfc,0x34,0xad,0xd5,0x01,0xc4,0x6e,0x4b},
	{0x08,0x08,0x98,0x8c,0xa2,0x03,0xcb,0x52,0x2b,0xfd,0xa3,0x05,0x13,0xfc,0x34,0xad,0xd5,0x01,0xc4,0x6e,0x4b},
	{0x08,0x08,0xeb,0xab,0x1c,0x03,0xcb,0x52,0x2b,0xfd,0x4f,0xe6,0x9a,0xfc,0x34,0xad,0xd5,0x01,0xc4,0x6e,0x4b},
	{0x08,0x09,0x43,0xb6,0x69,0x03,0xcb,0x52,0x2b,0xfc,0xf7,0xdb,0x4c,0xfc,0x34,0xad,0xd5,0x01,0xc4,0x6e,0x4b}
};

#else
// 150 bass shelf
unsigned char band1_reg[9][21] = {
	{0x6c,0x07,0xf6,0x27,0x94,0xf0,0x43,0x4e,0xed,0x07,0xc7,0x16,0x42,0x0f,0xbc,0x6b,0x06,0xf8,0x42,0x7c,0x1d},
	{0x6c,0x07,0xf8,0xa0,0xa3,0xf0,0x40,0x85,0xfd,0x07,0xc7,0x72,0xf1,0x0f,0xbf,0x45,0xe4,0xf8,0x3f,0xb8,0x4d},
	{0x6c,0x07,0xfb,0x16,0xf3,0xf0,0x3d,0xdb,0x8c,0x07,0xc7,0xb5,0x07,0x0f,0xc2,0x01,0xe5,0xf8,0x3d,0x11,0x77},
	{0x6c,0x07,0xfd,0x8b,0xaf,0xf0,0x3b,0x4e,0x6f,0x07,0xc7,0xdc,0xa3,0x0f,0xc4,0xa0,0x58,0xf8,0x3a,0x86,0x75},
	{0x6c,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x6c,0x08,0x02,0x75,0x12,0xf0,0x36,0x87,0xc1,0x07,0xc7,0xdc,0xa3,0x0f,0xc9,0x89,0x7e,0xf8,0x35,0xbf,0x89},
	{0x6c,0x08,0x04,0xec,0x12,0xf0,0x34,0x4c,0x1b,0x07,0xc7,0xb5,0x08,0x0f,0xcb,0xd6,0x89,0xf8,0x33,0x81,0x89},
	{0x6c,0x08,0x07,0x66,0x2f,0xf0,0x32,0x29,0x9c,0x07,0xc7,0x72,0xf2,0x0f,0xce,0x0a,0xb3,0xf8,0x31,0x5b,0x2f},
	{0x6c,0x08,0x09,0xe4,0x99,0xf0,0x30,0x1f,0x5b,0x07,0xc7,0x16,0x44,0x0f,0xd0,0x27,0x08,0xf8,0x2f,0x4b,0x86}
};

// 850 q factor , 0.35
unsigned char band2_reg[9][21] = {
	{0x08,0x07,0x0a,0x06,0x19,0xf3,0xed,0x79,0xce,0x05,0x1b,0xba,0xcb,0x0c,0x12,0x86,0x32,0xfb,0xda,0x3f,0x1b},
	{0x08,0x07,0x51,0x93,0x0a,0xf3,0x72,0xc3,0xb5,0x05,0x4f,0xa7,0x68,0x0c,0x8d,0x3c,0x4b,0xfb,0x5e,0xc5,0x8e},
	{0x08,0x07,0x92,0x54,0x95,0xf3,0x03,0xb4,0xbb,0x05,0x7e,0xa5,0xbd,0x0c,0xfc,0x4b,0x45,0xfa,0xef,0x05,0xad},
	{0x08,0x07,0xcc,0x63,0x29,0xf2,0xa0,0x22,0xf9,0x05,0xa8,0xc7,0x85,0x0d,0x5f,0xdd,0x07,0xfa,0x8a,0xd5,0x53},
	{0x08,0x08,0x00,0x00,0x00,0xf2,0x47,0x9e,0x8f,0x05,0xce,0x3c,0x16,0x0d,0xb8,0x61,0x71,0xfa,0x31,0xc3,0xea},
	{0x08,0x08,0x34,0xf2,0x6f,0xf2,0x47,0x9e,0x8f,0x05,0x99,0x49,0xa7,0x0d,0xb8,0x61,0x71,0xfa,0x31,0xc3,0xea},
	{0x08,0x08,0x73,0xdf,0xe8,0xf2,0x47,0x9e,0x8f,0x05,0x5a,0x5c,0x2d,0x0d,0xb8,0x61,0x71,0xfa,0x31,0xc3,0xea},
	{0x08,0x08,0xbe,0xaa,0x0d,0xf2,0x47,0x9e,0x8f,0x05,0x0f,0x92,0x08,0x0d,0xb8,0x61,0x71,0xfa,0x31,0xc3,0xea},
	{0x08,0x09,0x17,0x8d,0x4a,0xf2,0x47,0x9e,0x8f,0x04,0xb6,0xae,0xcc,0x0d,0xb8,0x61,0x71,0xfa,0x31,0xc3,0xea}
};

// 4200 treble shelf
unsigned char band3_reg[9][21] = {
	{0x1c,0x04,0x91,0xda,0x34,0xfa,0xe2,0xd7,0xdb,0x01,0xd6,0xb7,0xbb,0x0a,0xd9,0x08,0x66,0xfb,0xdb,0x8d,0xd0},
	{0x1c,0x05,0x41,0x73,0x47,0xf9,0xf1,0xea,0x92,0x02,0x30,0xd8,0xa4,0x0a,0xa3,0x2f,0xa6,0xfb,0xf8,0x99,0xdd},
	{0x1c,0x06,0x0b,0x99,0x3f,0xf8,0xd7,0x76,0xb4,0x02,0x9b,0x95,0xb9,0x0a,0x6b,0x74,0x5b,0xfc,0x15,0xe5,0xf9},
	{0x1c,0x06,0xf4,0x44,0x52,0xf7,0x8c,0xb3,0x29,0x03,0x19,0xd4,0xb7,0x0a,0x31,0xce,0x21,0xfc,0x33,0x65,0xae},
	{0x1c,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x1c,0x09,0x33,0xff,0x51,0xf4,0x45,0xb5,0x3e,0x04,0x5e,0xdf,0x34,0x09,0xb8,0xa3,0x2d,0xfc,0x6e,0xc9,0x10},
	{0x1c,0x0a,0x96,0x33,0x91,0xf2,0x36,0x0c,0xa0,0x05,0x2e,0x1f,0x2c,0x09,0x79,0x11,0xd1,0xfc,0x8c,0x8e,0xd3},
	{0x1c,0x0c,0x2d,0x65,0xdf,0xef,0xce,0xdb,0x27,0x06,0x21,0xf6,0x20,0x09,0x37,0x7c,0x79,0xfc,0xaa,0x4c,0x62},
	{0x1c,0x0e,0x01,0x53,0xe1,0xed,0x02,0x64,0x70,0x07,0x40,0x77,0xd1,0x08,0xf3,0xdf,0x84,0xfc,0xc7,0xf0,0x5a}
};

#endif

static void band_reg_proc(int band, unsigned long long mod) {
#ifdef EQ_12BAND_MODE
	switch (band) {
		case 1:
			tas5827_i2c_write_reg_list(band1_reg[mod - 1][0], &band1_reg[mod - 1][1], 20);
			break;
		case 2:
			tas5827_i2c_write_reg_list(band2_reg[mod - 1][0], &band2_reg[mod - 1][1], 20);
			break;
		case 3:
			tas5827_i2c_write_reg_list(band3_reg[mod - 1][0], &band3_reg[mod - 1][1], 20);
			break;
		case 4:
			tas5827_i2c_write_reg_list(band4_reg[mod - 1][0], &band4_reg[mod - 1][1], 20);
			break;
		case 5:
			tas5827_i2c_write_reg_list(band5_reg[mod - 1][0], &band5_reg[mod - 1][1], 20);
			break;
		case 6:
			tas5827_i2c_write_reg_list(band6_reg[mod - 1][0], &band6_reg[mod - 1][1], 20);
			break;
		case 7:
			tas5827_i2c_write_reg_list(band7_reg[mod - 1][0], &band7_reg[mod - 1][1], 20);
			break;
		case 8:
			tas5827_i2c_write_reg_list(band8_reg[mod - 1][0], &band8_reg[mod - 1][1], 20);
			break;
		case 9:
			tas5827_i2c_write_reg_list(band9_reg[mod - 1][0], &band9_reg[mod - 1][1], 20);
			break;
		case 10:
			tas5827_i2c_write_reg_list(band10_reg[mod - 1][0], &band10_reg[mod - 1][1], 20);
			break;
		case 11:
			tas5827_i2c_write_reg_list(band11_reg[mod - 1][0], &band11_reg[mod - 1][1], 20);
			break;
		case 12:
			tas5827_i2c_write_reg_list(band12_reg[mod - 1][0], &band12_reg[mod - 1][1], 20);
			break;
		default:
			break;
	}
#else
	switch (band) {
		case 1:
			printk(KERN_EMERG "3band band1 proc\n");
			tas5827_i2c_write_reg_list(band1_reg[mod - 1][0], &band1_reg[mod - 1][1], 20);
			break;
		case 2:
			printk(KERN_EMERG "3band band2 proc\n");
			tas5827_i2c_write_reg_list(band2_reg[mod - 1][0], &band2_reg[mod - 1][1], 20);
			break;
		case 3:
			printk(KERN_EMERG "3band band3 proc\n");
			tas5827_i2c_write_reg_list(band3_reg[mod - 1][0], &band3_reg[mod - 1][1], 20);
			break;
		default:
			break;
	}
#endif
}

static void band_proc(int band, unsigned long long mod)
{
	printk("[GGEC]tas5827 band is %d eq is (%llu)\n", band, mod);
	if ((mod == 0) || (mod > 9))
		return;
#ifdef EQ_12BAND_MODE
	if ((band >= 1) && (band <= 4)) {
		// switch to page 3
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x3, 1);
	} 	else if ((band >= 5) && (band <= 7)) {
		// switch to page 4
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x4, 1);
	}  else if ((band >= 8) && (band <= 11)) {
		// switch to page 1
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x1, 1);
	} 	if (band == 12) {
		// switch to page 2
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x2, 1);
	}
	band_reg_proc(band, mod);
#else
	if (band == 1) {
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x2, 1);
		band_reg_proc(band, mod);
	} else if ((band == 2) || (band == 3)) {
		tas5827_i2c_write_reg(0x00, 0x00, 1);
		tas5827_i2c_write_reg(0x7f, 0xaa, 1);
		tas5827_i2c_write_reg(0x00, 0x3, 1);
		band_reg_proc(band, mod);
	} else {
		// printk(KERN_EMERG "not used band\n");
	}
#endif
}

static int tas5827_eq_switch(unsigned long long eq)
{
	unsigned long mod = 0;
	int band12 = 0, band11 = 0, band10 = 0, band9 = 0, band8 = 0, band7 = 0;
	int band6 = 0, band5 = 0, band4 = 0, band3 = 0, band2 = 0, band1 = 0;
	int band = 12;

	if (eq_mode == eq) {
		printk(KERN_EMERG "EQ same eq mode, return, eq_mode is %lld\n", eq_mode);
		return 0;
	}

	switch (eq) {
		case 0:
			printk(KERN_EMERG "EQ set music mode\n");
			eq_mode = eq;
			transmit_registers(registers, sizeof(registers) / sizeof(registers[0]));
			break;
		case 1:
		case 2:
		case 3:
			printk(KERN_EMERG "EQ set podcast mode\n");
			eq_mode = eq;
			transmit_registers(registers_podcast, sizeof(registers_podcast) / sizeof(registers_podcast[0]));
			break;
		case 4: // no eq mode
			printk(KERN_EMERG "EQ set noeq mode\n");
			eq_mode = eq;
			transmit_registers(registers_bypass, sizeof(registers_bypass) / sizeof(registers_bypass[0]));
			break;
		default:
			if ((eq >= 111111111111ULL) && (eq <= 999999999999ULL)) {
				if ((eq_mode == 1) || (eq_mode == 2) || (eq_mode == 3) || (eq_mode == 4)) {
					transmit_registers(registers, sizeof(registers) / sizeof(registers[0])); // need based on music mode
				}
				printk(KERN_EMERG "EQ set cust mode\n");
				eq_mode = eq;
				while ( band > 0 ) {
					mod = do_div(eq, 10);
					switch (band) {
						case 12:
							if (mod != band12) {
								band_proc(12, mod);
							}
							break;
						case 11:
							if (mod != band11) {
								band_proc(11, mod);
							}
							break;
						case 10:
							if (mod != band10) {
								band_proc(10, mod);
							}
							break;
						case 9:
							if (mod != band9) {
								band_proc(9, mod);
							}
							break;
						case 8:
							if (mod != band8) {
								band_proc(8, mod);
							}
							break;
						case 7:
							if (mod != band7) {
								band_proc(7, mod);
							}
							break;
						case 6:
							if (mod != band6) {
								band_proc(6, mod);
							}
							break;
						case 5:
							if (mod != band5) {
								band_proc(5, mod);
							}
							break;
						case 4:
							if (mod != band4) {
								band_proc(4, mod);
							}
							break;
						case 3:
							if (mod != band3) {
								band_proc(3, mod);
							}
							break;
						case 2:
							if (mod != band2) {
								band_proc(2, mod);
							}
							break;
						case 1:
							if (mod != band1) {
								band_proc(1, mod);
							}
							break;
						default:
							break;
					}
					--band;
				}
			} else {
					printk(KERN_EMERG "[GGEC]tas5827 not support eq (%llu)\n", eq);
			}
			break;
	}
	return 0;
}
#endif

void left_volume_control(int vol)
{
	tas5827_left_volume = vol;
	printk(KERN_EMERG "[GGEC]volume_control:vol is %d\n",vol);

	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
	tas5827_i2c_write_reg(0x4c, tas5827_left_volume, 1);    //left volume register
}

void right_volume_control(int vol)
{
	tas5827_right_volume = vol;
	printk(KERN_EMERG "[GGEC]volume_control:vol is %d\n",vol);

	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
	tas5827_i2c_write_reg(0x4d, tas5827_right_volume, 1);    //right volume register
}

void enable_hwmute(void)
{
	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
	tas5827_i2c_write_reg(0x61, 0x0c, 1);
}

void config_automute_period(void)
{
	tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
	tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
	tas5827_i2c_write_reg(0x51, 0x33, 1);
}

static ssize_t mute_show(struct device *dev, struct device_attribute *attr,
            char *buf)
{
	return sprintf(buf, "%d\n", tas5827_mute);
}

static ssize_t mute_store(struct device *dev,
            struct device_attribute *attr, const char *buf,
            size_t count)
{
	sscanf(buf, "%du", &tas5827_mute);
	mute_control(tas5827_mute, 1);

	return count;
}

static DEVICE_ATTR(mute, S_IRUGO | S_IWUSR, mute_show, mute_store);

static int g_reg;
static ssize_t reg_show(struct device *dev, struct device_attribute *attr,
            char *buf)
{
	int value = 0, ret;
	printk("%s %d, g_reg is 0x%X\n",  __func__, __LINE__, g_reg);
	value = tas5827_i2c_read_reg(g_reg);
	printk("%s %d, value is 0x%X\n",  __func__, __LINE__, value);
	ret = sprintf(buf, "%d\n", value);
	return ret;
}

static ssize_t reg_store(struct device *dev,
            struct device_attribute *attr, const char *buf,
            size_t count)
{
	int value, en = 0;
	sscanf(buf, "0x%02x 0x%02x 0x%02x", &g_reg, &value, &en);
	printk("%s %d, g_reg is 0x%X, value is 0x%X, en is %d\n", __func__, __LINE__, g_reg, value, en);

	if (en) {
		printk("%s %d,update reg 0x%x value now\n",  __func__, __LINE__, g_reg);
		tas5827_i2c_write_reg(0x00, 0x00, 1);    //goto page0
		tas5827_i2c_write_reg(0x7f, 0x00, 1);    //goto book0
		tas5827_i2c_write_reg(g_reg, (uint8_t)value, 1);
	}
	return count;
}

static DEVICE_ATTR(reg, S_IRUGO | S_IWUSR, reg_show, reg_store);

static ssize_t left_volume_show(struct device *dev, struct device_attribute *attr,
            char *buf)
{
	return sprintf(buf, "%d\n", tas5827_left_volume);
}

static ssize_t left_volume_store(struct device *dev,
            struct device_attribute *attr, const char *buf,
            size_t count)
{
	sscanf(buf, "%du", &tas5827_left_volume);
	left_volume_control(tas5827_left_volume);

	return count;
}

static DEVICE_ATTR(left_volume, S_IRUGO | S_IWUSR, left_volume_show, left_volume_store);

static ssize_t right_volume_show(struct device *dev, struct device_attribute *attr,
            char *buf)
{
	return sprintf(buf, "%d\n", tas5827_right_volume);
}

static ssize_t right_volume_store(struct device *dev,
            struct device_attribute *attr, const char *buf,
            size_t count)
{
	sscanf(buf, "%du", &tas5827_right_volume);
	right_volume_control(tas5827_right_volume);

	return count;
}

static DEVICE_ATTR(right_volume, S_IRUGO | S_IWUSR, right_volume_show, right_volume_store);

static ssize_t eq_show(struct device *dev, struct device_attribute *attr,
            char *buf)
{
	return sprintf(buf, "%llu\n", eq_mode);
}

static ssize_t eq_store(struct device *dev,
            struct device_attribute *attr, const char *buf,
            size_t count)
{
	unsigned long long eq = 0;
	sscanf(buf, "%llu", &eq);
	tas5827_eq_switch(eq);
	return count;
}

static DEVICE_ATTR(eq, S_IRUGO | S_IWUSR, eq_show, eq_store);

static struct attribute *tas5827_attributes[] = {
    &dev_attr_left_volume.attr,
	&dev_attr_right_volume.attr,
    &dev_attr_reg.attr,
	&dev_attr_mute.attr,
	&dev_attr_eq.attr,
    NULL,
};

static const struct attribute_group tas5827_attr_group = {
    .attrs = tas5827_attributes,
};

int tas5827_open(struct inode *inode, struct file *file)
{
    printk("tas5827_open success!\n");

    return 0;
}

static struct file_operations tas5827_fops = {
	.owner = THIS_MODULE,
	.open  = tas5827_open,
};
 
static int tas5827_probe(struct i2c_client *i2c_client, const struct i2c_device_id *id)
{
    int ret = 0;
	struct device_node *np;

	printk("[GGEC]tas5827_probe\n");
    tas5827_client = i2c_client;
	
	np = i2c_client->dev.of_node;

	ret = tas5827_power_up(np);
	if(ret < 0)
	{
		printk(KERN_EMERG "[GGEC]tas5827_power_up failed!\n");
		return ret;
	}

	#ifdef FIRST_DBG
	tas5827_fast_init(i2c_client);  //通过设置3个寄存器，可以快速出声音
	#else
	tas5827_reg_init(i2c_client);
	#endif
	left_volume_control(DEFALT_CODEC_VOLUME_REG_VAL); // 48 <--> 0db , 60<--> - 6db   (12 * - 0.5)
	right_volume_control(DEFALT_CODEC_VOLUME_REG_VAL);
	enable_hwmute();
	config_automute_period();
	// gpio_direction_output(hwmute, 0); // unmute codec here
	if (tas5827_client->addr == 0x60) {
		tas5827_major_60 = register_chrdev(0, "tas5827_60", &tas5827_fops);
		tas5827_class_60 = class_create(THIS_MODULE, "tas5827_60");
		tas5827_device_60 = device_create(tas5827_class_60, NULL, MKDEV(tas5827_major_60, 0), NULL, "options");

		ret = sysfs_create_group(&tas5827_device_60->kobj, &tas5827_attr_group);
		if (ret) {
			printk("[GGEC]failed to register sysfs. err: %d\n", ret);
			return ret;
		}
	}
	
	if (tas5827_client->addr == 0x61) {
		tas5827_major_61 = register_chrdev(0, "tas5827_61", &tas5827_fops);
		tas5827_class_61 = class_create(THIS_MODULE, "tas5827_61");
		tas5827_device_61 = device_create(tas5827_class_61, NULL, MKDEV(tas5827_major_61, 0), NULL, "options");

		ret = sysfs_create_group(&tas5827_device_61->kobj, &tas5827_attr_group);
		if (ret) {
			printk("[GGEC]failed to register sysfs. err: %d\n", ret);
			return ret;
		}
	}

	ret = snd_soc_register_component(&i2c_client->dev,&tas5827_codec, &tas5827_dai, 1);
	if (ret != 0) {
		dev_err(&i2c_client->dev, "Failed to register codec (%d)\n", ret);
	}

	return ret;
}

static int tas5827_remove(struct i2c_client *i2c_client)
{
	printk("[GGEC]tas5827_remove \n");

	snd_soc_unregister_codec(&i2c_client->dev);
	dev_info(&i2c_client->dev, "i2c_client removed");

	return 0;
}

static const struct i2c_device_id tas5827_id[] = {
	{"tas5827", 0},  
	{}
};

const struct of_device_id of_match_table_tas5827[] = {
    {.compatible = "ti,tas5827"},
    {},
};
 
static struct i2c_driver tas5827_driver =
{
    .probe = tas5827_probe,
	.remove = tas5827_remove,
    .driver = {
        .owner = THIS_MODULE,
        .name = "tas5827_amplifier",
        .of_match_table = of_match_table_tas5827 
    },
	.id_table = tas5827_id,
};

static int tas5827_init(void)
{
    i2c_add_driver(&tas5827_driver);
    printk("tas5827_init \n");
    return 0;
}
static void tas5827_exit(void)
{
    printk("tas5827_exit \n");
    i2c_del_driver(&tas5827_driver);
}

MODULE_DESCRIPTION("ti tas5827 amp driver");
MODULE_AUTHOR("ggec<jian_qin@ggec.com.cn>");
MODULE_LICENSE("GPL");
late_initcall(tas5827_init);
module_exit(tas5827_exit);
